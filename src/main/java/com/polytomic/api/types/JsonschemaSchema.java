/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.polytomic.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.polytomic.api.core.ObjectMappers;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonDeserialize(builder = JsonschemaSchema.Builder.class)
public final class JsonschemaSchema {
    private final Optional<String> anchor;

    private final Optional<String> comment;

    private final Optional<Map<String, JsonschemaSchema>> defs;

    private final Optional<String> dynamicRef;

    private final Optional<String> id;

    private final Optional<String> ref;

    private final Optional<String> schema;

    private final Optional<JsonschemaSchema> additionalProperties;

    private final Optional<List<JsonschemaSchema>> allOf;

    private final Optional<List<JsonschemaSchema>> anyOf;

    private final Optional<Object> const_;

    private final Optional<JsonschemaSchema> contains;

    private final Optional<String> contentEncoding;

    private final Optional<String> contentMediaType;

    private final Optional<JsonschemaSchema> contentSchema;

    private final Optional<Object> default_;

    private final Optional<Map<String, List<String>>> dependentRequired;

    private final Optional<Map<String, JsonschemaSchema>> dependentSchemas;

    private final Optional<Boolean> deprecated;

    private final Optional<String> description;

    private final Optional<JsonschemaSchema> else_;

    private final Optional<List<Object>> enum_;

    private final Optional<List<Object>> examples;

    private final Optional<String> exclusiveMaximum;

    private final Optional<String> exclusiveMinimum;

    private final Optional<String> format;

    private final Optional<JsonschemaSchema> if_;

    private final Optional<JsonschemaSchema> items;

    private final Optional<Integer> maxContains;

    private final Optional<Integer> maxItems;

    private final Optional<Integer> maxLength;

    private final Optional<Integer> maxProperties;

    private final Optional<String> maximum;

    private final Optional<Integer> minContains;

    private final Optional<Integer> minItems;

    private final Optional<Integer> minLength;

    private final Optional<Integer> minProperties;

    private final Optional<String> minimum;

    private final Optional<String> multipleOf;

    private final Optional<JsonschemaSchema> not;

    private final Optional<List<JsonschemaSchema>> oneOf;

    private final Optional<String> pattern;

    private final Optional<Map<String, JsonschemaSchema>> patternProperties;

    private final Optional<List<JsonschemaSchema>> prefixItems;

    private final Optional<Map<String, Object>> properties;

    private final Optional<JsonschemaSchema> propertyNames;

    private final Optional<Boolean> readOnly;

    private final Optional<List<String>> required;

    private final Optional<JsonschemaSchema> then;

    private final Optional<String> title;

    private final Optional<String> type;

    private final Optional<Boolean> uniqueItems;

    private final Optional<Boolean> writeOnly;

    private final Map<String, Object> _additionalProperties;

    private JsonschemaSchema(
            Optional<String> anchor,
            Optional<String> comment,
            Optional<Map<String, JsonschemaSchema>> defs,
            Optional<String> dynamicRef,
            Optional<String> id,
            Optional<String> ref,
            Optional<String> schema,
            Optional<JsonschemaSchema> additionalProperties,
            Optional<List<JsonschemaSchema>> allOf,
            Optional<List<JsonschemaSchema>> anyOf,
            Optional<Object> const_,
            Optional<JsonschemaSchema> contains,
            Optional<String> contentEncoding,
            Optional<String> contentMediaType,
            Optional<JsonschemaSchema> contentSchema,
            Optional<Object> default_,
            Optional<Map<String, List<String>>> dependentRequired,
            Optional<Map<String, JsonschemaSchema>> dependentSchemas,
            Optional<Boolean> deprecated,
            Optional<String> description,
            Optional<JsonschemaSchema> else_,
            Optional<List<Object>> enum_,
            Optional<List<Object>> examples,
            Optional<String> exclusiveMaximum,
            Optional<String> exclusiveMinimum,
            Optional<String> format,
            Optional<JsonschemaSchema> if_,
            Optional<JsonschemaSchema> items,
            Optional<Integer> maxContains,
            Optional<Integer> maxItems,
            Optional<Integer> maxLength,
            Optional<Integer> maxProperties,
            Optional<String> maximum,
            Optional<Integer> minContains,
            Optional<Integer> minItems,
            Optional<Integer> minLength,
            Optional<Integer> minProperties,
            Optional<String> minimum,
            Optional<String> multipleOf,
            Optional<JsonschemaSchema> not,
            Optional<List<JsonschemaSchema>> oneOf,
            Optional<String> pattern,
            Optional<Map<String, JsonschemaSchema>> patternProperties,
            Optional<List<JsonschemaSchema>> prefixItems,
            Optional<Map<String, Object>> properties,
            Optional<JsonschemaSchema> propertyNames,
            Optional<Boolean> readOnly,
            Optional<List<String>> required,
            Optional<JsonschemaSchema> then,
            Optional<String> title,
            Optional<String> type,
            Optional<Boolean> uniqueItems,
            Optional<Boolean> writeOnly,
            Map<String, Object> _additionalProperties) {
        this.anchor = anchor;
        this.comment = comment;
        this.defs = defs;
        this.dynamicRef = dynamicRef;
        this.id = id;
        this.ref = ref;
        this.schema = schema;
        this.additionalProperties = additionalProperties;
        this.allOf = allOf;
        this.anyOf = anyOf;
        this.const_ = const_;
        this.contains = contains;
        this.contentEncoding = contentEncoding;
        this.contentMediaType = contentMediaType;
        this.contentSchema = contentSchema;
        this.default_ = default_;
        this.dependentRequired = dependentRequired;
        this.dependentSchemas = dependentSchemas;
        this.deprecated = deprecated;
        this.description = description;
        this.else_ = else_;
        this.enum_ = enum_;
        this.examples = examples;
        this.exclusiveMaximum = exclusiveMaximum;
        this.exclusiveMinimum = exclusiveMinimum;
        this.format = format;
        this.if_ = if_;
        this.items = items;
        this.maxContains = maxContains;
        this.maxItems = maxItems;
        this.maxLength = maxLength;
        this.maxProperties = maxProperties;
        this.maximum = maximum;
        this.minContains = minContains;
        this.minItems = minItems;
        this.minLength = minLength;
        this.minProperties = minProperties;
        this.minimum = minimum;
        this.multipleOf = multipleOf;
        this.not = not;
        this.oneOf = oneOf;
        this.pattern = pattern;
        this.patternProperties = patternProperties;
        this.prefixItems = prefixItems;
        this.properties = properties;
        this.propertyNames = propertyNames;
        this.readOnly = readOnly;
        this.required = required;
        this.then = then;
        this.title = title;
        this.type = type;
        this.uniqueItems = uniqueItems;
        this.writeOnly = writeOnly;
        this._additionalProperties = _additionalProperties;
    }

    @JsonProperty("$anchor")
    public Optional<String> getAnchor() {
        return anchor;
    }

    @JsonProperty("$comment")
    public Optional<String> getComment() {
        return comment;
    }

    @JsonProperty("$defs")
    public Optional<Map<String, JsonschemaSchema>> getDefs() {
        return defs;
    }

    @JsonProperty("$dynamicRef")
    public Optional<String> getDynamicRef() {
        return dynamicRef;
    }

    @JsonProperty("$id")
    public Optional<String> getId() {
        return id;
    }

    @JsonProperty("$ref")
    public Optional<String> getRef() {
        return ref;
    }

    @JsonProperty("$schema")
    public Optional<String> getSchema() {
        return schema;
    }

    @JsonProperty("additionalProperties")
    public Optional<JsonschemaSchema> getAdditionalProperties() {
        return additionalProperties;
    }

    @JsonProperty("allOf")
    public Optional<List<JsonschemaSchema>> getAllOf() {
        return allOf;
    }

    @JsonProperty("anyOf")
    public Optional<List<JsonschemaSchema>> getAnyOf() {
        return anyOf;
    }

    @JsonProperty("const")
    public Optional<Object> getConst() {
        return const_;
    }

    @JsonProperty("contains")
    public Optional<JsonschemaSchema> getContains() {
        return contains;
    }

    @JsonProperty("contentEncoding")
    public Optional<String> getContentEncoding() {
        return contentEncoding;
    }

    @JsonProperty("contentMediaType")
    public Optional<String> getContentMediaType() {
        return contentMediaType;
    }

    @JsonProperty("contentSchema")
    public Optional<JsonschemaSchema> getContentSchema() {
        return contentSchema;
    }

    @JsonProperty("default")
    public Optional<Object> getDefault() {
        return default_;
    }

    @JsonProperty("dependentRequired")
    public Optional<Map<String, List<String>>> getDependentRequired() {
        return dependentRequired;
    }

    @JsonProperty("dependentSchemas")
    public Optional<Map<String, JsonschemaSchema>> getDependentSchemas() {
        return dependentSchemas;
    }

    @JsonProperty("deprecated")
    public Optional<Boolean> getDeprecated() {
        return deprecated;
    }

    @JsonProperty("description")
    public Optional<String> getDescription() {
        return description;
    }

    @JsonProperty("else")
    public Optional<JsonschemaSchema> getElse() {
        return else_;
    }

    @JsonProperty("enum")
    public Optional<List<Object>> getEnum() {
        return enum_;
    }

    @JsonProperty("examples")
    public Optional<List<Object>> getExamples() {
        return examples;
    }

    @JsonProperty("exclusiveMaximum")
    public Optional<String> getExclusiveMaximum() {
        return exclusiveMaximum;
    }

    @JsonProperty("exclusiveMinimum")
    public Optional<String> getExclusiveMinimum() {
        return exclusiveMinimum;
    }

    @JsonProperty("format")
    public Optional<String> getFormat() {
        return format;
    }

    @JsonProperty("if")
    public Optional<JsonschemaSchema> getIf() {
        return if_;
    }

    @JsonProperty("items")
    public Optional<JsonschemaSchema> getItems() {
        return items;
    }

    @JsonProperty("maxContains")
    public Optional<Integer> getMaxContains() {
        return maxContains;
    }

    @JsonProperty("maxItems")
    public Optional<Integer> getMaxItems() {
        return maxItems;
    }

    @JsonProperty("maxLength")
    public Optional<Integer> getMaxLength() {
        return maxLength;
    }

    @JsonProperty("maxProperties")
    public Optional<Integer> getMaxProperties() {
        return maxProperties;
    }

    @JsonProperty("maximum")
    public Optional<String> getMaximum() {
        return maximum;
    }

    @JsonProperty("minContains")
    public Optional<Integer> getMinContains() {
        return minContains;
    }

    @JsonProperty("minItems")
    public Optional<Integer> getMinItems() {
        return minItems;
    }

    @JsonProperty("minLength")
    public Optional<Integer> getMinLength() {
        return minLength;
    }

    @JsonProperty("minProperties")
    public Optional<Integer> getMinProperties() {
        return minProperties;
    }

    @JsonProperty("minimum")
    public Optional<String> getMinimum() {
        return minimum;
    }

    @JsonProperty("multipleOf")
    public Optional<String> getMultipleOf() {
        return multipleOf;
    }

    @JsonProperty("not")
    public Optional<JsonschemaSchema> getNot() {
        return not;
    }

    @JsonProperty("oneOf")
    public Optional<List<JsonschemaSchema>> getOneOf() {
        return oneOf;
    }

    @JsonProperty("pattern")
    public Optional<String> getPattern() {
        return pattern;
    }

    @JsonProperty("patternProperties")
    public Optional<Map<String, JsonschemaSchema>> getPatternProperties() {
        return patternProperties;
    }

    @JsonProperty("prefixItems")
    public Optional<List<JsonschemaSchema>> getPrefixItems() {
        return prefixItems;
    }

    @JsonProperty("properties")
    public Optional<Map<String, Object>> getProperties() {
        return properties;
    }

    @JsonProperty("propertyNames")
    public Optional<JsonschemaSchema> getPropertyNames() {
        return propertyNames;
    }

    @JsonProperty("readOnly")
    public Optional<Boolean> getReadOnly() {
        return readOnly;
    }

    @JsonProperty("required")
    public Optional<List<String>> getRequired() {
        return required;
    }

    @JsonProperty("then")
    public Optional<JsonschemaSchema> getThen() {
        return then;
    }

    @JsonProperty("title")
    public Optional<String> getTitle() {
        return title;
    }

    @JsonProperty("type")
    public Optional<String> getType() {
        return type;
    }

    @JsonProperty("uniqueItems")
    public Optional<Boolean> getUniqueItems() {
        return uniqueItems;
    }

    @JsonProperty("writeOnly")
    public Optional<Boolean> getWriteOnly() {
        return writeOnly;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof JsonschemaSchema && equalTo((JsonschemaSchema) other);
    }

    @JsonAnyGetter
    public Map<String, Object> _getAdditionalProperties() {
        return this._additionalProperties;
    }

    private boolean equalTo(JsonschemaSchema other) {
        return anchor.equals(other.anchor)
                && comment.equals(other.comment)
                && defs.equals(other.defs)
                && dynamicRef.equals(other.dynamicRef)
                && id.equals(other.id)
                && ref.equals(other.ref)
                && schema.equals(other.schema)
                && additionalProperties.equals(other.additionalProperties)
                && allOf.equals(other.allOf)
                && anyOf.equals(other.anyOf)
                && const_.equals(other.const_)
                && contains.equals(other.contains)
                && contentEncoding.equals(other.contentEncoding)
                && contentMediaType.equals(other.contentMediaType)
                && contentSchema.equals(other.contentSchema)
                && default_.equals(other.default_)
                && dependentRequired.equals(other.dependentRequired)
                && dependentSchemas.equals(other.dependentSchemas)
                && deprecated.equals(other.deprecated)
                && description.equals(other.description)
                && else_.equals(other.else_)
                && enum_.equals(other.enum_)
                && examples.equals(other.examples)
                && exclusiveMaximum.equals(other.exclusiveMaximum)
                && exclusiveMinimum.equals(other.exclusiveMinimum)
                && format.equals(other.format)
                && if_.equals(other.if_)
                && items.equals(other.items)
                && maxContains.equals(other.maxContains)
                && maxItems.equals(other.maxItems)
                && maxLength.equals(other.maxLength)
                && maxProperties.equals(other.maxProperties)
                && maximum.equals(other.maximum)
                && minContains.equals(other.minContains)
                && minItems.equals(other.minItems)
                && minLength.equals(other.minLength)
                && minProperties.equals(other.minProperties)
                && minimum.equals(other.minimum)
                && multipleOf.equals(other.multipleOf)
                && not.equals(other.not)
                && oneOf.equals(other.oneOf)
                && pattern.equals(other.pattern)
                && patternProperties.equals(other.patternProperties)
                && prefixItems.equals(other.prefixItems)
                && properties.equals(other.properties)
                && propertyNames.equals(other.propertyNames)
                && readOnly.equals(other.readOnly)
                && required.equals(other.required)
                && then.equals(other.then)
                && title.equals(other.title)
                && type.equals(other.type)
                && uniqueItems.equals(other.uniqueItems)
                && writeOnly.equals(other.writeOnly);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.anchor,
                this.comment,
                this.defs,
                this.dynamicRef,
                this.id,
                this.ref,
                this.schema,
                this.additionalProperties,
                this.allOf,
                this.anyOf,
                this.const_,
                this.contains,
                this.contentEncoding,
                this.contentMediaType,
                this.contentSchema,
                this.default_,
                this.dependentRequired,
                this.dependentSchemas,
                this.deprecated,
                this.description,
                this.else_,
                this.enum_,
                this.examples,
                this.exclusiveMaximum,
                this.exclusiveMinimum,
                this.format,
                this.if_,
                this.items,
                this.maxContains,
                this.maxItems,
                this.maxLength,
                this.maxProperties,
                this.maximum,
                this.minContains,
                this.minItems,
                this.minLength,
                this.minProperties,
                this.minimum,
                this.multipleOf,
                this.not,
                this.oneOf,
                this.pattern,
                this.patternProperties,
                this.prefixItems,
                this.properties,
                this.propertyNames,
                this.readOnly,
                this.required,
                this.then,
                this.title,
                this.type,
                this.uniqueItems,
                this.writeOnly);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<String> anchor = Optional.empty();

        private Optional<String> comment = Optional.empty();

        private Optional<Map<String, JsonschemaSchema>> defs = Optional.empty();

        private Optional<String> dynamicRef = Optional.empty();

        private Optional<String> id = Optional.empty();

        private Optional<String> ref = Optional.empty();

        private Optional<String> schema = Optional.empty();

        private Optional<JsonschemaSchema> additionalProperties = Optional.empty();

        private Optional<List<JsonschemaSchema>> allOf = Optional.empty();

        private Optional<List<JsonschemaSchema>> anyOf = Optional.empty();

        private Optional<Object> const_ = Optional.empty();

        private Optional<JsonschemaSchema> contains = Optional.empty();

        private Optional<String> contentEncoding = Optional.empty();

        private Optional<String> contentMediaType = Optional.empty();

        private Optional<JsonschemaSchema> contentSchema = Optional.empty();

        private Optional<Object> default_ = Optional.empty();

        private Optional<Map<String, List<String>>> dependentRequired = Optional.empty();

        private Optional<Map<String, JsonschemaSchema>> dependentSchemas = Optional.empty();

        private Optional<Boolean> deprecated = Optional.empty();

        private Optional<String> description = Optional.empty();

        private Optional<JsonschemaSchema> else_ = Optional.empty();

        private Optional<List<Object>> enum_ = Optional.empty();

        private Optional<List<Object>> examples = Optional.empty();

        private Optional<String> exclusiveMaximum = Optional.empty();

        private Optional<String> exclusiveMinimum = Optional.empty();

        private Optional<String> format = Optional.empty();

        private Optional<JsonschemaSchema> if_ = Optional.empty();

        private Optional<JsonschemaSchema> items = Optional.empty();

        private Optional<Integer> maxContains = Optional.empty();

        private Optional<Integer> maxItems = Optional.empty();

        private Optional<Integer> maxLength = Optional.empty();

        private Optional<Integer> maxProperties = Optional.empty();

        private Optional<String> maximum = Optional.empty();

        private Optional<Integer> minContains = Optional.empty();

        private Optional<Integer> minItems = Optional.empty();

        private Optional<Integer> minLength = Optional.empty();

        private Optional<Integer> minProperties = Optional.empty();

        private Optional<String> minimum = Optional.empty();

        private Optional<String> multipleOf = Optional.empty();

        private Optional<JsonschemaSchema> not = Optional.empty();

        private Optional<List<JsonschemaSchema>> oneOf = Optional.empty();

        private Optional<String> pattern = Optional.empty();

        private Optional<Map<String, JsonschemaSchema>> patternProperties = Optional.empty();

        private Optional<List<JsonschemaSchema>> prefixItems = Optional.empty();

        private Optional<Map<String, Object>> properties = Optional.empty();

        private Optional<JsonschemaSchema> propertyNames = Optional.empty();

        private Optional<Boolean> readOnly = Optional.empty();

        private Optional<List<String>> required = Optional.empty();

        private Optional<JsonschemaSchema> then = Optional.empty();

        private Optional<String> title = Optional.empty();

        private Optional<String> type = Optional.empty();

        private Optional<Boolean> uniqueItems = Optional.empty();

        private Optional<Boolean> writeOnly = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> _additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(JsonschemaSchema other) {
            anchor(other.getAnchor());
            comment(other.getComment());
            defs(other.getDefs());
            dynamicRef(other.getDynamicRef());
            id(other.getId());
            ref(other.getRef());
            schema(other.getSchema());
            additionalProperties(other.getAdditionalProperties());
            allOf(other.getAllOf());
            anyOf(other.getAnyOf());
            const_(other.getConst());
            contains(other.getContains());
            contentEncoding(other.getContentEncoding());
            contentMediaType(other.getContentMediaType());
            contentSchema(other.getContentSchema());
            default_(other.getDefault());
            dependentRequired(other.getDependentRequired());
            dependentSchemas(other.getDependentSchemas());
            deprecated(other.getDeprecated());
            description(other.getDescription());
            else_(other.getElse());
            enum_(other.getEnum());
            examples(other.getExamples());
            exclusiveMaximum(other.getExclusiveMaximum());
            exclusiveMinimum(other.getExclusiveMinimum());
            format(other.getFormat());
            if_(other.getIf());
            items(other.getItems());
            maxContains(other.getMaxContains());
            maxItems(other.getMaxItems());
            maxLength(other.getMaxLength());
            maxProperties(other.getMaxProperties());
            maximum(other.getMaximum());
            minContains(other.getMinContains());
            minItems(other.getMinItems());
            minLength(other.getMinLength());
            minProperties(other.getMinProperties());
            minimum(other.getMinimum());
            multipleOf(other.getMultipleOf());
            not(other.getNot());
            oneOf(other.getOneOf());
            pattern(other.getPattern());
            patternProperties(other.getPatternProperties());
            prefixItems(other.getPrefixItems());
            properties(other.getProperties());
            propertyNames(other.getPropertyNames());
            readOnly(other.getReadOnly());
            required(other.getRequired());
            then(other.getThen());
            title(other.getTitle());
            type(other.getType());
            uniqueItems(other.getUniqueItems());
            writeOnly(other.getWriteOnly());
            return this;
        }

        @JsonSetter(value = "$anchor", nulls = Nulls.SKIP)
        public Builder anchor(Optional<String> anchor) {
            this.anchor = anchor;
            return this;
        }

        public Builder anchor(String anchor) {
            this.anchor = Optional.of(anchor);
            return this;
        }

        @JsonSetter(value = "$comment", nulls = Nulls.SKIP)
        public Builder comment(Optional<String> comment) {
            this.comment = comment;
            return this;
        }

        public Builder comment(String comment) {
            this.comment = Optional.of(comment);
            return this;
        }

        @JsonSetter(value = "$defs", nulls = Nulls.SKIP)
        public Builder defs(Optional<Map<String, JsonschemaSchema>> defs) {
            this.defs = defs;
            return this;
        }

        public Builder defs(Map<String, JsonschemaSchema> defs) {
            this.defs = Optional.of(defs);
            return this;
        }

        @JsonSetter(value = "$dynamicRef", nulls = Nulls.SKIP)
        public Builder dynamicRef(Optional<String> dynamicRef) {
            this.dynamicRef = dynamicRef;
            return this;
        }

        public Builder dynamicRef(String dynamicRef) {
            this.dynamicRef = Optional.of(dynamicRef);
            return this;
        }

        @JsonSetter(value = "$id", nulls = Nulls.SKIP)
        public Builder id(Optional<String> id) {
            this.id = id;
            return this;
        }

        public Builder id(String id) {
            this.id = Optional.of(id);
            return this;
        }

        @JsonSetter(value = "$ref", nulls = Nulls.SKIP)
        public Builder ref(Optional<String> ref) {
            this.ref = ref;
            return this;
        }

        public Builder ref(String ref) {
            this.ref = Optional.of(ref);
            return this;
        }

        @JsonSetter(value = "$schema", nulls = Nulls.SKIP)
        public Builder schema(Optional<String> schema) {
            this.schema = schema;
            return this;
        }

        public Builder schema(String schema) {
            this.schema = Optional.of(schema);
            return this;
        }

        @JsonSetter(value = "additionalProperties", nulls = Nulls.SKIP)
        public Builder additionalProperties(Optional<JsonschemaSchema> additionalProperties) {
            this.additionalProperties = additionalProperties;
            return this;
        }

        public Builder additionalProperties(JsonschemaSchema additionalProperties) {
            this.additionalProperties = Optional.of(additionalProperties);
            return this;
        }

        @JsonSetter(value = "allOf", nulls = Nulls.SKIP)
        public Builder allOf(Optional<List<JsonschemaSchema>> allOf) {
            this.allOf = allOf;
            return this;
        }

        public Builder allOf(List<JsonschemaSchema> allOf) {
            this.allOf = Optional.of(allOf);
            return this;
        }

        @JsonSetter(value = "anyOf", nulls = Nulls.SKIP)
        public Builder anyOf(Optional<List<JsonschemaSchema>> anyOf) {
            this.anyOf = anyOf;
            return this;
        }

        public Builder anyOf(List<JsonschemaSchema> anyOf) {
            this.anyOf = Optional.of(anyOf);
            return this;
        }

        @JsonSetter(value = "const", nulls = Nulls.SKIP)
        public Builder const_(Optional<Object> const_) {
            this.const_ = const_;
            return this;
        }

        public Builder const_(Object const_) {
            this.const_ = Optional.of(const_);
            return this;
        }

        @JsonSetter(value = "contains", nulls = Nulls.SKIP)
        public Builder contains(Optional<JsonschemaSchema> contains) {
            this.contains = contains;
            return this;
        }

        public Builder contains(JsonschemaSchema contains) {
            this.contains = Optional.of(contains);
            return this;
        }

        @JsonSetter(value = "contentEncoding", nulls = Nulls.SKIP)
        public Builder contentEncoding(Optional<String> contentEncoding) {
            this.contentEncoding = contentEncoding;
            return this;
        }

        public Builder contentEncoding(String contentEncoding) {
            this.contentEncoding = Optional.of(contentEncoding);
            return this;
        }

        @JsonSetter(value = "contentMediaType", nulls = Nulls.SKIP)
        public Builder contentMediaType(Optional<String> contentMediaType) {
            this.contentMediaType = contentMediaType;
            return this;
        }

        public Builder contentMediaType(String contentMediaType) {
            this.contentMediaType = Optional.of(contentMediaType);
            return this;
        }

        @JsonSetter(value = "contentSchema", nulls = Nulls.SKIP)
        public Builder contentSchema(Optional<JsonschemaSchema> contentSchema) {
            this.contentSchema = contentSchema;
            return this;
        }

        public Builder contentSchema(JsonschemaSchema contentSchema) {
            this.contentSchema = Optional.of(contentSchema);
            return this;
        }

        @JsonSetter(value = "default", nulls = Nulls.SKIP)
        public Builder default_(Optional<Object> default_) {
            this.default_ = default_;
            return this;
        }

        public Builder default_(Object default_) {
            this.default_ = Optional.of(default_);
            return this;
        }

        @JsonSetter(value = "dependentRequired", nulls = Nulls.SKIP)
        public Builder dependentRequired(Optional<Map<String, List<String>>> dependentRequired) {
            this.dependentRequired = dependentRequired;
            return this;
        }

        public Builder dependentRequired(Map<String, List<String>> dependentRequired) {
            this.dependentRequired = Optional.of(dependentRequired);
            return this;
        }

        @JsonSetter(value = "dependentSchemas", nulls = Nulls.SKIP)
        public Builder dependentSchemas(Optional<Map<String, JsonschemaSchema>> dependentSchemas) {
            this.dependentSchemas = dependentSchemas;
            return this;
        }

        public Builder dependentSchemas(Map<String, JsonschemaSchema> dependentSchemas) {
            this.dependentSchemas = Optional.of(dependentSchemas);
            return this;
        }

        @JsonSetter(value = "deprecated", nulls = Nulls.SKIP)
        public Builder deprecated(Optional<Boolean> deprecated) {
            this.deprecated = deprecated;
            return this;
        }

        public Builder deprecated(Boolean deprecated) {
            this.deprecated = Optional.of(deprecated);
            return this;
        }

        @JsonSetter(value = "description", nulls = Nulls.SKIP)
        public Builder description(Optional<String> description) {
            this.description = description;
            return this;
        }

        public Builder description(String description) {
            this.description = Optional.of(description);
            return this;
        }

        @JsonSetter(value = "else", nulls = Nulls.SKIP)
        public Builder else_(Optional<JsonschemaSchema> else_) {
            this.else_ = else_;
            return this;
        }

        public Builder else_(JsonschemaSchema else_) {
            this.else_ = Optional.of(else_);
            return this;
        }

        @JsonSetter(value = "enum", nulls = Nulls.SKIP)
        public Builder enum_(Optional<List<Object>> enum_) {
            this.enum_ = enum_;
            return this;
        }

        public Builder enum_(List<Object> enum_) {
            this.enum_ = Optional.of(enum_);
            return this;
        }

        @JsonSetter(value = "examples", nulls = Nulls.SKIP)
        public Builder examples(Optional<List<Object>> examples) {
            this.examples = examples;
            return this;
        }

        public Builder examples(List<Object> examples) {
            this.examples = Optional.of(examples);
            return this;
        }

        @JsonSetter(value = "exclusiveMaximum", nulls = Nulls.SKIP)
        public Builder exclusiveMaximum(Optional<String> exclusiveMaximum) {
            this.exclusiveMaximum = exclusiveMaximum;
            return this;
        }

        public Builder exclusiveMaximum(String exclusiveMaximum) {
            this.exclusiveMaximum = Optional.of(exclusiveMaximum);
            return this;
        }

        @JsonSetter(value = "exclusiveMinimum", nulls = Nulls.SKIP)
        public Builder exclusiveMinimum(Optional<String> exclusiveMinimum) {
            this.exclusiveMinimum = exclusiveMinimum;
            return this;
        }

        public Builder exclusiveMinimum(String exclusiveMinimum) {
            this.exclusiveMinimum = Optional.of(exclusiveMinimum);
            return this;
        }

        @JsonSetter(value = "format", nulls = Nulls.SKIP)
        public Builder format(Optional<String> format) {
            this.format = format;
            return this;
        }

        public Builder format(String format) {
            this.format = Optional.of(format);
            return this;
        }

        @JsonSetter(value = "if", nulls = Nulls.SKIP)
        public Builder if_(Optional<JsonschemaSchema> if_) {
            this.if_ = if_;
            return this;
        }

        public Builder if_(JsonschemaSchema if_) {
            this.if_ = Optional.of(if_);
            return this;
        }

        @JsonSetter(value = "items", nulls = Nulls.SKIP)
        public Builder items(Optional<JsonschemaSchema> items) {
            this.items = items;
            return this;
        }

        public Builder items(JsonschemaSchema items) {
            this.items = Optional.of(items);
            return this;
        }

        @JsonSetter(value = "maxContains", nulls = Nulls.SKIP)
        public Builder maxContains(Optional<Integer> maxContains) {
            this.maxContains = maxContains;
            return this;
        }

        public Builder maxContains(Integer maxContains) {
            this.maxContains = Optional.of(maxContains);
            return this;
        }

        @JsonSetter(value = "maxItems", nulls = Nulls.SKIP)
        public Builder maxItems(Optional<Integer> maxItems) {
            this.maxItems = maxItems;
            return this;
        }

        public Builder maxItems(Integer maxItems) {
            this.maxItems = Optional.of(maxItems);
            return this;
        }

        @JsonSetter(value = "maxLength", nulls = Nulls.SKIP)
        public Builder maxLength(Optional<Integer> maxLength) {
            this.maxLength = maxLength;
            return this;
        }

        public Builder maxLength(Integer maxLength) {
            this.maxLength = Optional.of(maxLength);
            return this;
        }

        @JsonSetter(value = "maxProperties", nulls = Nulls.SKIP)
        public Builder maxProperties(Optional<Integer> maxProperties) {
            this.maxProperties = maxProperties;
            return this;
        }

        public Builder maxProperties(Integer maxProperties) {
            this.maxProperties = Optional.of(maxProperties);
            return this;
        }

        @JsonSetter(value = "maximum", nulls = Nulls.SKIP)
        public Builder maximum(Optional<String> maximum) {
            this.maximum = maximum;
            return this;
        }

        public Builder maximum(String maximum) {
            this.maximum = Optional.of(maximum);
            return this;
        }

        @JsonSetter(value = "minContains", nulls = Nulls.SKIP)
        public Builder minContains(Optional<Integer> minContains) {
            this.minContains = minContains;
            return this;
        }

        public Builder minContains(Integer minContains) {
            this.minContains = Optional.of(minContains);
            return this;
        }

        @JsonSetter(value = "minItems", nulls = Nulls.SKIP)
        public Builder minItems(Optional<Integer> minItems) {
            this.minItems = minItems;
            return this;
        }

        public Builder minItems(Integer minItems) {
            this.minItems = Optional.of(minItems);
            return this;
        }

        @JsonSetter(value = "minLength", nulls = Nulls.SKIP)
        public Builder minLength(Optional<Integer> minLength) {
            this.minLength = minLength;
            return this;
        }

        public Builder minLength(Integer minLength) {
            this.minLength = Optional.of(minLength);
            return this;
        }

        @JsonSetter(value = "minProperties", nulls = Nulls.SKIP)
        public Builder minProperties(Optional<Integer> minProperties) {
            this.minProperties = minProperties;
            return this;
        }

        public Builder minProperties(Integer minProperties) {
            this.minProperties = Optional.of(minProperties);
            return this;
        }

        @JsonSetter(value = "minimum", nulls = Nulls.SKIP)
        public Builder minimum(Optional<String> minimum) {
            this.minimum = minimum;
            return this;
        }

        public Builder minimum(String minimum) {
            this.minimum = Optional.of(minimum);
            return this;
        }

        @JsonSetter(value = "multipleOf", nulls = Nulls.SKIP)
        public Builder multipleOf(Optional<String> multipleOf) {
            this.multipleOf = multipleOf;
            return this;
        }

        public Builder multipleOf(String multipleOf) {
            this.multipleOf = Optional.of(multipleOf);
            return this;
        }

        @JsonSetter(value = "not", nulls = Nulls.SKIP)
        public Builder not(Optional<JsonschemaSchema> not) {
            this.not = not;
            return this;
        }

        public Builder not(JsonschemaSchema not) {
            this.not = Optional.of(not);
            return this;
        }

        @JsonSetter(value = "oneOf", nulls = Nulls.SKIP)
        public Builder oneOf(Optional<List<JsonschemaSchema>> oneOf) {
            this.oneOf = oneOf;
            return this;
        }

        public Builder oneOf(List<JsonschemaSchema> oneOf) {
            this.oneOf = Optional.of(oneOf);
            return this;
        }

        @JsonSetter(value = "pattern", nulls = Nulls.SKIP)
        public Builder pattern(Optional<String> pattern) {
            this.pattern = pattern;
            return this;
        }

        public Builder pattern(String pattern) {
            this.pattern = Optional.of(pattern);
            return this;
        }

        @JsonSetter(value = "patternProperties", nulls = Nulls.SKIP)
        public Builder patternProperties(Optional<Map<String, JsonschemaSchema>> patternProperties) {
            this.patternProperties = patternProperties;
            return this;
        }

        public Builder patternProperties(Map<String, JsonschemaSchema> patternProperties) {
            this.patternProperties = Optional.of(patternProperties);
            return this;
        }

        @JsonSetter(value = "prefixItems", nulls = Nulls.SKIP)
        public Builder prefixItems(Optional<List<JsonschemaSchema>> prefixItems) {
            this.prefixItems = prefixItems;
            return this;
        }

        public Builder prefixItems(List<JsonschemaSchema> prefixItems) {
            this.prefixItems = Optional.of(prefixItems);
            return this;
        }

        @JsonSetter(value = "properties", nulls = Nulls.SKIP)
        public Builder properties(Optional<Map<String, Object>> properties) {
            this.properties = properties;
            return this;
        }

        public Builder properties(Map<String, Object> properties) {
            this.properties = Optional.of(properties);
            return this;
        }

        @JsonSetter(value = "propertyNames", nulls = Nulls.SKIP)
        public Builder propertyNames(Optional<JsonschemaSchema> propertyNames) {
            this.propertyNames = propertyNames;
            return this;
        }

        public Builder propertyNames(JsonschemaSchema propertyNames) {
            this.propertyNames = Optional.of(propertyNames);
            return this;
        }

        @JsonSetter(value = "readOnly", nulls = Nulls.SKIP)
        public Builder readOnly(Optional<Boolean> readOnly) {
            this.readOnly = readOnly;
            return this;
        }

        public Builder readOnly(Boolean readOnly) {
            this.readOnly = Optional.of(readOnly);
            return this;
        }

        @JsonSetter(value = "required", nulls = Nulls.SKIP)
        public Builder required(Optional<List<String>> required) {
            this.required = required;
            return this;
        }

        public Builder required(List<String> required) {
            this.required = Optional.of(required);
            return this;
        }

        @JsonSetter(value = "then", nulls = Nulls.SKIP)
        public Builder then(Optional<JsonschemaSchema> then) {
            this.then = then;
            return this;
        }

        public Builder then(JsonschemaSchema then) {
            this.then = Optional.of(then);
            return this;
        }

        @JsonSetter(value = "title", nulls = Nulls.SKIP)
        public Builder title(Optional<String> title) {
            this.title = title;
            return this;
        }

        public Builder title(String title) {
            this.title = Optional.of(title);
            return this;
        }

        @JsonSetter(value = "type", nulls = Nulls.SKIP)
        public Builder type(Optional<String> type) {
            this.type = type;
            return this;
        }

        public Builder type(String type) {
            this.type = Optional.of(type);
            return this;
        }

        @JsonSetter(value = "uniqueItems", nulls = Nulls.SKIP)
        public Builder uniqueItems(Optional<Boolean> uniqueItems) {
            this.uniqueItems = uniqueItems;
            return this;
        }

        public Builder uniqueItems(Boolean uniqueItems) {
            this.uniqueItems = Optional.of(uniqueItems);
            return this;
        }

        @JsonSetter(value = "writeOnly", nulls = Nulls.SKIP)
        public Builder writeOnly(Optional<Boolean> writeOnly) {
            this.writeOnly = writeOnly;
            return this;
        }

        public Builder writeOnly(Boolean writeOnly) {
            this.writeOnly = Optional.of(writeOnly);
            return this;
        }

        public JsonschemaSchema build() {
            return new JsonschemaSchema(
                    anchor,
                    comment,
                    defs,
                    dynamicRef,
                    id,
                    ref,
                    schema,
                    additionalProperties,
                    allOf,
                    anyOf,
                    const_,
                    contains,
                    contentEncoding,
                    contentMediaType,
                    contentSchema,
                    default_,
                    dependentRequired,
                    dependentSchemas,
                    deprecated,
                    description,
                    else_,
                    enum_,
                    examples,
                    exclusiveMaximum,
                    exclusiveMinimum,
                    format,
                    if_,
                    items,
                    maxContains,
                    maxItems,
                    maxLength,
                    maxProperties,
                    maximum,
                    minContains,
                    minItems,
                    minLength,
                    minProperties,
                    minimum,
                    multipleOf,
                    not,
                    oneOf,
                    pattern,
                    patternProperties,
                    prefixItems,
                    properties,
                    propertyNames,
                    readOnly,
                    required,
                    then,
                    title,
                    type,
                    uniqueItems,
                    writeOnly,
                    _additionalProperties);
        }
    }
}
